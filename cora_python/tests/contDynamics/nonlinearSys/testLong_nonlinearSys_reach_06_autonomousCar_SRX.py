"""
testLong_nonlinearSys_reach_06_autonomousCar_SRX - unit_test_function of 
   nonlinear reachability analysis for following a reference trajectory
   The test is similar to test_nonlinear_reach_05_autonomousCar, but here a 
   specialized algorithm is tested that can be run in parallel; the 
   parallelization is not switched on since setting up the threads consumes 
   too much time during unit testing.
   
   Checks the solution of an autonomous car following a reference
   trajectory; It is checked whether the reachable set is enclosed in the
   initial set after a certain amount of time.

Syntax:
    pytest cora_python/tests/contDynamics/nonlinearSys/testLong_nonlinearSys_reach_06_autonomousCar_SRX.py

Inputs:
    -

Outputs:
    res - true/false

Authors:       Matthias Althoff
Written:       15-March-2012
Last update:   16-August-2016
Last revision: ---
               Automatic python translation: Florian NÃ¼ssel BA 2025
"""

import numpy as np
import pytest
import scipy.io
import os
import math
import copy as copy_module
from cora_python.contDynamics.nonlinearSys import NonlinearSys
from cora_python.contDynamics.nonlinearSys.linearize import linearize
from cora_python.contDynamics.contDynamics.derivatives import derivatives
from cora_python.contDynamics.linearSys.linearSys import LinearSys
from cora_python.contDynamics.linearSys.particularSolution_timeVarying import particularSolution_timeVarying
from cora_python.contDynamics.linearSys.particularSolution_constant import particularSolution_constant
from cora_python.contSet.zonotope import Zonotope
from cora_python.contSet.interval import Interval
from cora_python.contSet.zonotope.cartProd_ import cartProd_
from cora_python.models.Cora.autonomousCar.SRXparameters import SRXparameters
from cora_python.models.Cora.autonomousCar.DOTcontrol_SRX_velEq import DOTcontrol_SRX_velEq
from cora_python.models.Cora.autonomousCar.DOTBicycleDynamics_SRX_velEq import DOTBicycleDynamics_SRX_velEq
from cora_python.models.Cora.autonomousCar.DOTBicycleDynamics_controlled_SRX_velEq import DOTBicycleDynamics_controlled_SRX_velEq


def modelFactors(u):
    """
    modelFactors - model factors of the autonomous car
    
    This function is generated by getModelFactors/createModelFactors.
    The values are hardcoded from the MATLAB generated file.
    
    Args:
        u: input vector (velocity and yaw angle)
        
    Returns:
        c: model factors vector
    """
    # These values are from cora_matlab/models/Cora/autonomousCar/modelFactors.m
    # They are computed symbolically and then hardcoded
    c = np.zeros((7, 1))
    c[0, 0] = 461536341122712295 / 20123953278623141748760163385344
    c[1, 0] = -238017840354865539851459120204375 / 1257747079913946359297510211584
    c[2, 0] = -(2839534093871312996715940101197875 * np.sin(u[2])) / 138981052330491072702374878380032
    c[3, 0] = (2839534093871312996715940101197875 * np.cos(u[2])) / 138981052330491072702374878380032
    c[4, 0] = 14197670469356564983579700505989375 / 69490526165245536351187439190016
    c[5, 0] = 8518602281613938990147820303593625 / 277962104660982145404749756760064
    c[6, 0] = -543340113647656165220626413105554067117196772157 / 2854495385411919762116571938898990272765493248
    
    return c


def linError_constVel(obj, w, IH, IH_y):
    """
    linError_constVel - computes linearization error for constant velocity model
    
    Args:
        obj: nonlinear system object
        w: input vector
        IH: interval hull
        IH_y: interval hull for sensor noise
        
    Returns:
        err: linearization error vector
    """
    # obtain model factors
    c = modelFactors(w)
    c_abs = np.abs(c)
    
    # helper values
    min_x = IH.inf
    max_x = IH.sup
    
    # extreme absolute values
    # x_1
    max_abs_x1 = max(np.abs(min_x[0, 0]), np.abs(max_x[0, 0]))
    # x_3
    max_abs_x3 = max(np.abs(min_x[2, 0]), np.abs(max_x[2, 0]))
    # x_4
    min_abs_x4 = 7.4  # hard coded!!
    max_abs_x4 = 7.6  # hard coded!!
    
    # auxiliary variables
    aux_min_1 = w[0] - IH.inf[3, 0] - IH_y.inf[0, 0]
    aux_max_1 = w[0] - IH.sup[3, 0] - IH_y.sup[0, 0]
    tilde_IM_1 = max(np.abs(aux_min_1), np.abs(aux_max_1))
    
    aux_min_2 = w[1] - IH.inf[4, 0] - IH_y.inf[1, 0]
    aux_max_2 = w[1] - IH.sup[4, 0] - IH_y.sup[1, 0]
    tilde_IM_2 = max(np.abs(aux_min_2), np.abs(aux_max_2))
    
    aux_min_3 = w[2] - IH.inf[1, 0] - IH_y.inf[2, 0]
    aux_max_3 = w[2] - IH.sup[1, 0] - IH_y.sup[2, 0]
    tilde_IM_3 = max(np.abs(aux_min_3), np.abs(aux_max_3))
    
    aux_min_4 = w[3] - IH.inf[2, 0] - IH_y.inf[3, 0]
    aux_max_4 = w[3] - IH.sup[2, 0] - IH_y.sup[3, 0]
    tilde_IM_4 = max(np.abs(aux_min_4), np.abs(aux_max_4))
    
    # cos and sin max
    min_angle = min_x[0, 0] + min_x[1, 0]
    max_angle = max_x[0, 0] + max_x[1, 0]
    
    # ASSUME that angles are between -pi and pi!!
    # cosinus ranges
    if max_angle < 0:
        cos_min = np.cos(min_angle)
        cos_max = np.cos(max_angle)
    elif min_angle > 0:
        cos_min = np.cos(max_angle)
        cos_max = np.cos(min_angle)
    else:
        cos_min = min(np.cos(min_angle), np.cos(max_angle))
        cos_max = 1
    
    # sinus ranges
    if max_angle < -np.pi / 2:
        sin_min = np.sin(max_angle)
        sin_max = np.sin(min_angle)
    elif min_angle > np.pi / 2:
        sin_min = np.sin(max_angle)
        sin_max = np.sin(min_angle)
    elif min_angle > -np.pi / 2 and max_angle < np.pi / 2:
        sin_min = np.sin(min_angle)
        sin_max = np.sin(max_angle)
    elif min_angle < -np.pi / 2 and max_angle < np.pi / 2:
        sin_min = -1
        sin_max = max(np.sin(min_angle), np.sin(max_angle))
    elif min_angle > -np.pi / 2 and max_angle > np.pi / 2:
        sin_min = min(np.sin(min_angle), np.sin(max_angle))
        sin_max = 1
    
    # auxiliary variables for sin and cos
    Sm = max(np.abs(sin_min), np.abs(sin_max))
    Cm = max(np.abs(cos_min), np.abs(cos_max))
    
    # translate intervals by linearization point
    IH = IH + (-obj.linError['p']['x'])
    
    # obtain maximum absolute values within IH, IHinput
    IHinf = np.abs(IH.inf)
    IHsup = np.abs(IH.sup)
    dx_new = np.maximum(IHinf, IHsup)
    
    # conversion
    dx = np.zeros((6, 1))
    dx[3, 0] = 0.2  # delta v; hard coded!!
    dx[4, 0] = dx_new[3, 0]
    dx[5, 0] = dx_new[4, 0]
    
    IHinf_y = np.abs(IH_y.inf)
    IHsup_y = np.abs(IH_y.sup)
    dy = np.maximum(IHinf_y, IHsup_y)
    
    # compute linearization error by hand-derived Lagrange remainders
    # first coordinate
    err = np.zeros((6, 1))
    err[0, 0] = 2 / (min_abs_x4**2) * (c_abs[1, 0] * dx[0, 0] + c_abs[4, 0] * (dx[1, 0] + dy[2, 0]) +
                                       c_abs[2, 0] * (dx[4, 0] + dy[0, 0]) + c_abs[3, 0] * (dx[5, 0] + dy[1, 0])) * dx[3, 0] + \
               2 / (min_abs_x4**3) * (c_abs[1, 0] * max_abs_x1 + c_abs[2, 0] * tilde_IM_1 +
                                      c_abs[3, 0] * tilde_IM_2 + c_abs[4, 0] * tilde_IM_3 + c_abs[5, 0] * tilde_IM_4) * dx[3, 0]**2 + \
               4 / (min_abs_x4**3) * c_abs[0, 0] * dx[2, 0] * dx[3, 0] + \
               6 / (min_abs_x4**4) * c_abs[0, 0] * max_abs_x3 * dx[3, 0]**2
    
    err[1, 0] = 0
    
    err[2, 0] = 2 / (min_abs_x4**2) * c_abs[6, 0] * dx[2, 0] * dx[3, 0] + \
               2 / (min_abs_x4**3) * c_abs[6, 0] * max_abs_x3 * dx[3, 0]**2
    
    err[3, 0] = max_abs_x4 * Cm * (dx[0, 0] + dx[1, 0])**2 + 2 * Sm * (dx[0, 0] + dx[1, 0]) * dx[3, 0]
    err[4, 0] = max_abs_x4 * Sm * (dx[0, 0] + dx[1, 0])**2 + 2 * Cm * (dx[0, 0] + dx[1, 0]) * dx[3, 0]
    
    err[5, 0] = 0
    
    # divide by 2 since the second order Taylor term has factor 1/2!
    err = 0.5 * err
    
    return err


def taylorMatrices(linsys, timeStep, truncationOrder):
    """
    taylorMatrices - computes the remainder matrix of the exponential matrix
    and the correction matrices for the state and input
    
    Args:
        linsys: linearSys object
        timeStep: time step size
        truncationOrder: maximum order for Taylor expansion
        
    Returns:
        E: remainder matrix of exponential matrix
        F: correction matrix for the state
        G: correction matrix for the input
    """
    from cora_python.contDynamics.linearSys.private.priv_expmRemainder import priv_expmRemainder
    from cora_python.contDynamics.linearSys.private.priv_correctionMatrixState import priv_correctionMatrixState
    from cora_python.contDynamics.linearSys.private.priv_correctionMatrixInput import priv_correctionMatrixInput
    
    # since this function is public, we cannot assume that taylorLinSys has
    # already been instantiated
    if not hasattr(linsys, 'taylor') or linsys.taylor is None:
        from cora_python.g.classes.taylorLinSys import TaylorLinSys
        linsys.taylor = TaylorLinSys(linsys.A)
    
    # compute remainder of exponential matrix
    E = priv_expmRemainder(linsys, timeStep, truncationOrder)
    
    # compute correction matrices
    F = priv_correctionMatrixState(linsys, timeStep, truncationOrder)
    G = priv_correctionMatrixInput(linsys, timeStep, truncationOrder)
    
    return E, F, G


def aux_preReach(sys, params, options):
    """
    aux_preReach - prepares reachable set computation for linear systems
    
    Args:
        sys: linearSys object
        params: parameters dict (must contain 'uTrans' and 'U')
        options: options dict (must contain 'timeStep' and 'taylorTerms')
        
    Returns:
        S: struct with precomputed values
    """
    # compute auxiliary interval matrices
    E, F, G = taylorMatrices(sys, options['timeStep'], options['taylorTerms'])
    
    # compute particular solutions
    Pu, inputCorr = particularSolution_constant(sys, params['uTrans'],
                                                 options['timeStep'], options['taylorTerms'])
    PU = particularSolution_timeVarying(sys, params['U'],
                                        options['timeStep'], options['taylorTerms'])
    
    # read out exponential matrix
    eAt = sys.getTaylor('eAdt', {'timeStep': options['timeStep']})
    
    # return in a dict (struct equivalent)
    S = {
        'eAt': eAt,
        'E': E,
        'F': F,
        'G': G,
        'Pu': Pu,
        'PU': PU,
        'inputCorr': inputCorr
    }
    
    return S


def aux_postReach(Rinit, R_tp, RV, F, inputCorr, c):
    """
    aux_postReach - computes the reachable continuous set for the first time 
    interval as a postprocessing step
    
    Args:
        Rinit: initial reachable set
        R_tp: time point reachable set
        RV: reachable set due to input
        F: correction matrix
        inputCorr: input correction
        c: linearization point
        
    Returns:
        Rnext: dict with 'tp' and 'ti' reachable sets
        IH: interval hull
    """
    # time interval solution
    R_err = F * (Rinit + (-c)) + inputCorr
    R_ti = Rinit.enclose(R_tp) + R_err
    
    # write results to reachable set struct Rfirst
    Rnext = {}
    Rnext['tp'] = R_tp + RV
    Rnext['ti'] = R_ti + RV
    
    # compute enclosing hull
    IH_init = Rinit.interval()
    IH_tp = R_tp.interval()
    IH_err = (R_err + RV).interval()
    
    IH = (IH_init | IH_tp) + IH_err
    
    return Rnext, IH


def aux_reach(sys_init, params, options):
    """
    aux_reach - custom reachability analysis function for specialized algorithm
    
    Args:
        sys_init: nonlinearSys object
        params: parameters dict
        options: options dict
        
    Returns:
        Rcont: list of reachable sets (cell array equivalent)
    """
    derivatives(sys_init, options)
    
    # obtain factors for initial state and input solution
    options['factor'] = []
    for i in range(1, options['taylorTerms'] + 2):
        # compute initial state factor
        options['factor'].append(options['timeStep']**i / math.factorial(i))
    
    # obtain intervalhull of uncertain sensor values
    IH_u = params['U'].interval()
    IH_y = Interval(IH_u.inf[5:9, :], IH_u.sup[5:9, :])
    
    # precompute linearizations
    timeSteps = int(np.ceil(params['tFinal'] / options['timeStep']))
    
    linParams = [None] * timeSteps
    linOptions = [None] * timeSteps
    sys = [None] * timeSteps
    linsys = [None] * timeSteps
    RallError = [None] * (timeSteps + 1)
    
    for iSet in range(timeSteps):
        # set input
        if iSet > 19:  # iSet is 0-based, so >19 means >=20
            delayInd = 20
        else:
            delayInd = 0
        params['uTrans'] = params['uTransVec'][:, iSet - delayInd].reshape(-1, 1)
        
        # get first linearized system
        options['linearizationPoint'] = options['xStep'][:, iSet].reshape(-1, 1)
        sysTmp, linsys[iSet], linParams[iSet], linOptions[iSet] = \
            linearize(sys_init, None, params, options)
        sys[iSet] = sysTmp.copy()
    
    S = []
    for iSet in range(timeSteps):
        # prepare reachable set computations
        S.append(aux_preReach(linsys[iSet], linParams[iSet], linOptions[iSet]))
    
    # compute initial additional set due to linearization error
    V = Zonotope(np.zeros_like(options['expVector']), np.diag(options['expVector'].flatten()))
    RallError[0] = particularSolution_timeVarying(linsys[0],
                                                   V, options['timeStep'], options['taylorTerms'])
    
    # initialize
    Rtp = params['R0']
    
    Rcont = [None] * timeSteps
    for iSet in range(timeSteps):
        # set input and center
        if iSet > 29:  # iSet is 0-based, so >29 means >=30
            delayInd = 30
        else:
            delayInd = 0
        params['uTrans'] = params['uTransVec'][:, iSet - delayInd].reshape(-1, 1)
        c = options['xStep'][:, iSet].reshape(-1, 1)
        
        # translate Rinit by linearization point
        Rinit = Rtp.reduce(options['reductionTechnique'], options['zonotopeOrder'])
        Rdelta = Rinit + (-c)
        
        # first time step homogeneous solution
        R_hom_tp = S[iSet]['eAt'] * Rdelta + S[iSet]['Pu']
        
        # translate reachable sets by linearization point
        R_hom_tp = R_hom_tp + c
        
        # do post computations
        R_hom, IH_hom = aux_postReach(Rinit, R_hom_tp,
                                      S[iSet]['PU'], S[iSet]['F'], S[iSet]['inputCorr'], c)
        
        # compute maximum reachable set due to maximal allowed linearization error
        IH_max = IH_hom + RallError[iSet].interval()
        
        # obtain linearization error
        err = linError_constVel(sys[iSet], params['uTrans'].flatten(), IH_max, IH_y)
        
        # compute performance index of linearization error
        perfInd = np.max(err.flatten() / options['expVector'].flatten())
        
        # compute reachable set due to the linearization error
        V = Zonotope(np.zeros_like(err), np.diag(err.flatten()))
        Rerror = particularSolution_timeVarying(linsys[iSet],
                                                V, options['timeStep'], options['taylorTerms'])
        
        # update RallError
        RallError[iSet + 1] = Rerror.enlarge(1.8)
        options['expVector'] = 1.8 * err
        
        # add intervalhull of actual error
        Rti = R_hom['ti'] + Rerror
        Rtp = R_hom['tp'] + Rerror
        
        # save reachable set
        Rcont[iSet] = Rti
    
    return Rcont


class TestLongNonlinearSysReach06AutonomousCarSRX:
    """Test class for nonlinearSys reach functionality (autonomousCar SRX long test)"""
    
    def test_long_nonlinearSys_reach_06_autonomousCar_SRX(self):
        """Test reach for autonomous car SRX example"""
        # Parameters --------------------------------------------------------------
        dim_x = 6
        
        # load data
        # MATLAB location: cora_matlab/models/Cora/contDynamics/nonlinearSys/models/
        from cora_python.g.macros.CORAROOT import CORAROOT
        mat_file_path_SRX = os.path.join(CORAROOT(), 'models', 'Cora', 'contDynamics', 'nonlinearSys', 'models', 'SRX_lc_data.mat')
        data_SRX = scipy.io.loadmat(mat_file_path_SRX)
        x_cad = data_SRX['x_cad']
        
        # obtain interval hull of initial states
        V = np.zeros((6, 13))
        for i in range(13):
            V[0, i] = 0  # slip
            V[1, i] = x_cad[i, 0][1, 0]  # yaw angle
            V[2, i] = x_cad[i, 0][2, 0]  # yaw rate
            V[3, i] = x_cad[i, 0][3, 0]  # x-pos
            V[4, i] = x_cad[i, 0][4, 0]  # y-pos
            V[5, i] = x_cad[i, 0][5, 0]  # wheel angle
        
        # initial set
        V_min = np.min(V, axis=1).reshape(-1, 1)
        V_max = np.max(V, axis=1).reshape(-1, 1)
        I_init = Interval(V_min, V_max)
        Z_init = I_init.zonotope()
        
        # Reachability Settings ---------------------------------------------------
        params = {
            'tStart': 0,
            'tFinal': 7.5,
            'x0': Z_init.c,
            'R0': Z_init,
            'X_sample': Zonotope(
                np.zeros((dim_x, 1)),
                1.8 * np.diag([0.1, 0.1, 1, 0.5, 1, 1])
            )
        }
        
        options = {
            'timeStep': 0.01,
            'taylorTerms': 4,
            'zonotopeOrder': 800,
            'reductionTechnique': 'girard',
            'alg': 'lin',
            'tensorOrder': 2
        }
        
        # load reference trajectory
        # MATLAB location: cora_matlab/models/Cora/contDynamics/nonlinearSys/models/
        mat_file_path_uTraj = os.path.join(CORAROOT(), 'models', 'Cora', 'contDynamics', 'nonlinearSys', 'models', 'uTraj_manSpeed.mat')
        data_uTraj = scipy.io.loadmat(mat_file_path_uTraj)
        uTraj = data_uTraj['uTraj']
        
        # reference index
        refInd_start = 1597 - 1  # Convert to 0-based indexing
        refInd_end = 1597 + 750 - 1 - 1  # Convert to 0-based indexing
        u_ref = uTraj[:, refInd_start:refInd_end+1]
        
        # obtain parameters and model factors based on friction coefficient mu=1
        p = SRXparameters()
        # getModelFactors(p, 1) sets global variables - modelFactors function is already defined
        
        # input consists of reference trajectory u_ref, sensor noise y
        num_time_steps = u_ref.shape[1]
        params['uTransVec'] = np.vstack([u_ref, np.zeros((4, num_time_steps))])
        U_ref = Zonotope(np.zeros((u_ref.shape[0], 1)))
        Y = Zonotope(
            np.zeros((4, 1)),
            4 * np.diag([0.02, 0.02, 0.05 * np.pi / 180, 0.05 * np.pi / 180])
        )
        params['U'] = cartProd_(U_ref, Y)
        
        options['expVector'] = np.array([[0.2], [0], [0.25], [0.25], [0.15], [0]])
        
        # System Dynamics ---------------------------------------------------------
        carDyn = NonlinearSys(DOTBicycleDynamics_controlled_SRX_velEq, states=6, inputs=9)
        
        # Simulation --------------------------------------------------------------
        # generate ode options
        # stepsizeOptions = odeset('MaxStep', params['tFinal'] - params['tStart'])
        # opt = odeset(stepsizeOptions)
        
        # compute single simulation
        inputChanges = int(np.ceil(params['tFinal'] / options['timeStep']))
        finalTime = params['tFinal']
        options['xStep'] = np.zeros((dim_x, inputChanges + 1))
        options['xStep'][:, 0] = params['x0'].flatten()
        
        x = [None] * inputChanges
        t = [None] * inputChanges
        
        for iChange in range(inputChanges):
            # reset options
            params['tStart'] = params['tFinal']
            params['tFinal'] = params['tFinal'] + finalTime / inputChanges
            params['u'] = params['uTransVec'][:, iChange].reshape(-1, 1)
            if iChange > 0:
                params['x0'] = x[iChange - 1][-1, :].reshape(-1, 1)
            
            # simulate hybrid automaton
            # MATLAB: [t{iChange},x{iChange}] = simulate(carDyn,params,opt);
            # In Python, simulate is called as a method on the system object
            t[iChange], x[iChange], _, _ = carDyn.simulate(params, {})
            options['xStep'][:, iChange + 1] = x[iChange][-1, :]
        
        # reset options
        params['tStart'] = 0
        params['tFinal'] = finalTime
        
        # Reachability Analysis ---------------------------------------------------
        R = aux_reach(carDyn, params, options)
        
        # Verification -----------------------------------------------------------
        # enclose result by interval
        IH = R[-1].interval()
        
        # saved result
        IH_saved = Interval(
            np.array([[-0.0476364668386505], [2.6863478436703030], [-0.2675705463855188], 
                     [64.0741842006564468], [27.8702340052197002], [-0.0958282012281481]]),
            np.array([[-0.0016227388002018], [2.7558057378008112], [-0.0343461012859574], 
                     [64.4733925792921241], [28.2414003942370044], [-0.0057006695447072]])
        )
        
        # final result
        assert IH.isequal(IH_saved, 1e-8), \
            f"Interval hull {IH} does not match saved result {IH_saved}"
        
        # test completed
        res = True
        
        return res


def testLong_nonlinearSys_reach_06_autonomousCar_SRX():
    """Test function for nonlinearSys reach method (autonomousCar SRX long test).
    
    Runs all test methods to verify correct implementation.
    """
    test = TestLongNonlinearSysReach06AutonomousCarSRX()
    result = test.test_long_nonlinearSys_reach_06_autonomousCar_SRX()
    
    print("testLong_nonlinearSys_reach_06_autonomousCar_SRX: all tests passed")
    return result


if __name__ == "__main__":
    testLong_nonlinearSys_reach_06_autonomousCar_SRX()
