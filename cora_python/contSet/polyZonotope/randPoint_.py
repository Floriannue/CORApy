import numpy as np
from typing import Union

from cora_python.contSet.polyZonotope.polyZonotope import PolyZonotope
from cora_python.contSet.interval.interval import Interval
from cora_python.g.functions.matlab.validate.postprocessing.CORAerror import CORAerror

def randPoint_(pZ: PolyZonotope, N: Union[int, str] = 1, type: str = 'standard', *varargin) -> np.ndarray:
    """
    randPoint_ - generates a random point within a polynomial zonotope

    Syntax:
        p = randPoint_(pZ)
        p = randPoint_(pZ,N)
        p = randPoint_(pZ,N,type)
        p = randPoint_(pZ,'all','extreme')

    Inputs:
        pZ - polyZonotope object
        N - number of random points
        type - type of the random point ('standard' or 'extreme')
               Note that for 'extreme', the generated points might not all be
               extremal.

    Outputs:
        p - random points in R^n
    """

    if not (type == 'standard' or type == 'extreme'):
        raise CORAerror('CORA:noSpecificAlg', type, pZ)

    # get object properties
    n = pZ.dim()
    m = pZ.id.shape[0] # length(pZ.id)
    q = pZ.GI.shape[1] # size(pZ.GI,2)

    # compute random points for factor domain interval alpha in [-1,1]
    # MATLAB: dom = interval(-ones(m+q,1),ones(m+q,1));
    # interval constructor should handle 1D arrays or scalars correctly
    dom = Interval(-np.ones((m + q, 1)), np.ones((m + q, 1)))

    # MATLAB: fac = randPoint_(dom,N,type);
    fac = dom.randPoint_(N, type)
    
    # MATLAB: N = size(fac, 2); % in case N = 'all'
    # Python's N should already be an integer or 'all'. If N was 'all', fac.shape[1] is the actual count.
    if isinstance(N, str) and N == 'all':
        N_actual = fac.shape[1] # Use actual number of points generated by interval_randPoint_
    else:
        N_actual = N

    # center
    # MATLAB: p = pZ.c;
    p = np.tile(pZ.c, (1, N_actual)) # Replicate center N times to match generated points

    # dependent generators
    # MATLAB: if ~isempty(pZ.G)
    if pZ.G.size > 0:
        # MATLAB: fac_dep = fac(1:m, :);
        fac_dep = fac[0:m, :]
        
        # MATLAB: fac_dep = reshape(fac_dep, m, 1, N); # Reshape to (m, 1, N) for broadcasting with E
        fac_dep_reshaped = fac_dep.reshape(m, 1, N_actual)
        
        # MATLAB: fac_dep = prod(fac_dep .^ pZ.E, 1); # Element-wise power, then product along first dim
        # pZ.E is (p, N), where p is length of id (m here), N is num_dependent_generators (pZ.G.shape[1])
        # This is a matrix-vector product implicitly in MATLAB: (m, 1, N) element-wise ^ (m, num_gens)
        # then product over axis 0 results in (1, num_gens, N)
        
        # For each point (column in fac_dep), raise each factor to the power specified by pZ.E rows
        # (fac_dep_reshaped[factor_idx, 0, point_idx] ** pZ.E[factor_idx, generator_idx])
        # Then take product over factor_idx
        
        # Using einsum for element-wise power and product sum
        # pZ.E (m_id, num_dep_gens)
        # fac_dep_reshaped (m_id, 1, N_actual)
        # The result of power operation will be (m_id, num_dep_gens, N_actual)
        
        # Example: if E is (2,3) and fac_dep_reshaped is (2,1,5)
        # (fac_dep_reshaped[:,0,:])[:,None,:] --> (m_id, 1, N_actual)
        # E[:,:,None] --> (m_id, num_dep_gens, 1)
        # Result is (m_id, num_dep_gens, N_actual)
        # This needs careful broadcasting. Let's try direct approach first.
        
        # Create an expanded version of E to align with fac_dep for element-wise power
        # E_expanded: (m, num_dependent_gens, 1)
        E_expanded = pZ.E[:, :, np.newaxis] # (m, num_dep_gens, 1)

        # fac_dep_expanded: (m, 1, N_actual)
        fac_dep_expanded = fac_dep.reshape(m, 1, N_actual)

        # Element-wise power: (m, num_dep_gens, N_actual)
        powered_factors = fac_dep_expanded ** E_expanded

        # Product along axis 0 (over m_id): (1, num_dep_gens, N_actual)
        fac_prod = np.prod(powered_factors, axis=0)

        # MATLAB: dep = sum(pZ.G .* fac_dep, 2);
        # pZ.G is (n, num_dep_gens). fac_prod is (1, num_dep_gens, N_actual)
        # Needs to be (n, num_dep_gens) * (num_dep_gens, N_actual) for proper matrix multiplication or sum(element-wise_mul) for each column of pZ.G
        
        # Reshape fac_prod to (num_dep_gens, N_actual) for dot product
        fac_prod_2d = fac_prod.reshape(pZ.G.shape[1], N_actual)

        # Matrix multiplication: (n, num_dep_gens) @ (num_dep_gens, N_actual) = (n, N_actual)
        dep = pZ.G @ fac_prod_2d
        
        # MATLAB: dep = reshape(dep, n, N);
        # This is already (n, N_actual)
        
        p = p + dep

    # independent generators
    # MATLAB: if ~isempty(pZ.GI)
    if pZ.GI.size > 0:
        # MATLAB: fac_ind = fac(m+1:end, :);
        fac_ind = fac[m:, :]
        
        # MATLAB: fac_ind = reshape(fac_ind, 1, [], N); % Reshape to (1, q, N)
        fac_ind_reshaped = fac_ind.reshape(1, q, N_actual)

        # MATLAB: ind = sum(pZ.GI .* fac_ind, 2);
        # pZ.GI is (n, q). fac_ind_reshaped is (1, q, N_actual)
        # Broadcasting rules for element-wise multiplication apply
        # (n, q) * (1, q, N_actual) -> (n, q, N_actual)
        # Sum along axis 1 (q dimension) to get (n, 1, N_actual)
        
        ind = np.sum(pZ.GI[:, :, np.newaxis] * fac_ind_reshaped, axis=1, keepdims=True)

        # MATLAB: ind = reshape(ind, n, N);
        ind_reshaped = ind.reshape(n, N_actual)
        
        p = p + ind_reshaped

    return p
